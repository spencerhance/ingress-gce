/*
Copyright 2019 Google LLC
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
https://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// This file was generated by "go run gen/main.go". Do not edit directly.
// directly.
package composite

import (
	"encoding/json"
	"fmt"

	"k8s.io/klog"

	gcecloud "github.com/GoogleCloudPlatform/k8s-cloud-provider/pkg/cloud"
	"github.com/GoogleCloudPlatform/k8s-cloud-provider/pkg/cloud/meta"
	computealpha "google.golang.org/api/compute/v0.alpha"
	computebeta "google.golang.org/api/compute/v0.beta"
	compute "google.golang.org/api/compute/v1"
	"google.golang.org/api/googleapi"
	"k8s.io/kubernetes/pkg/cloudprovider/providers/gce"
)

// Backend is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type Backend struct {
	BalancingMode             string   `json:"balancingMode,omitempty"`
	CapacityScaler            float64  `json:"capacityScaler,omitempty"`
	Description               string   `json:"description,omitempty"`
	Failover                  bool     `json:"failover,omitempty"`
	Group                     string   `json:"group,omitempty"`
	MaxConnections            int64    `json:"maxConnections,omitempty"`
	MaxConnectionsPerEndpoint int64    `json:"maxConnectionsPerEndpoint,omitempty"`
	MaxConnectionsPerInstance int64    `json:"maxConnectionsPerInstance,omitempty"`
	MaxRate                   int64    `json:"maxRate,omitempty"`
	MaxRatePerEndpoint        float64  `json:"maxRatePerEndpoint,omitempty"`
	MaxRatePerInstance        float64  `json:"maxRatePerInstance,omitempty"`
	MaxUtilization            float64  `json:"maxUtilization,omitempty"`
	ForceSendFields           []string `json:"-"`
	NullFields                []string `json:"-"`
}

// BackendService is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendService struct {
	// Version keeps track of the intended compute version for this BackendService.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version                  meta.Version
	AffinityCookieTtlSec     int64                               `json:"affinityCookieTtlSec,omitempty"`
	AppEngineBackend         *BackendServiceAppEngineBackend     `json:"appEngineBackend,omitempty"`
	Backends                 []*Backend                          `json:"backends,omitempty"`
	CdnPolicy                *BackendServiceCdnPolicy            `json:"cdnPolicy,omitempty"`
	CloudFunctionBackend     *BackendServiceCloudFunctionBackend `json:"cloudFunctionBackend,omitempty"`
	ConnectionDraining       *ConnectionDraining                 `json:"connectionDraining,omitempty"`
	CreationTimestamp        string                              `json:"creationTimestamp,omitempty"`
	CustomRequestHeaders     []string                            `json:"customRequestHeaders,omitempty"`
	Description              string                              `json:"description,omitempty"`
	EnableCDN                bool                                `json:"enableCDN,omitempty"`
	FailoverPolicy           *BackendServiceFailoverPolicy       `json:"failoverPolicy,omitempty"`
	Fingerprint              string                              `json:"fingerprint,omitempty"`
	HealthChecks             []string                            `json:"healthChecks,omitempty"`
	Iap                      *BackendServiceIAP                  `json:"iap,omitempty"`
	Id                       uint64                              `json:"id,omitempty,string"`
	Kind                     string                              `json:"kind,omitempty"`
	LoadBalancingScheme      string                              `json:"loadBalancingScheme,omitempty"`
	Name                     string                              `json:"name,omitempty"`
	Port                     int64                               `json:"port,omitempty"`
	PortName                 string                              `json:"portName,omitempty"`
	Protocol                 string                              `json:"protocol,omitempty"`
	Region                   string                              `json:"region,omitempty"`
	SecurityPolicy           string                              `json:"securityPolicy,omitempty"`
	SelfLink                 string                              `json:"selfLink,omitempty"`
	SessionAffinity          string                              `json:"sessionAffinity,omitempty"`
	TimeoutSec               int64                               `json:"timeoutSec,omitempty"`
	googleapi.ServerResponse `json:"-"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// BackendServiceAppEngineBackend is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceAppEngineBackend struct {
	AppEngineService string   `json:"appEngineService,omitempty"`
	TargetProject    string   `json:"targetProject,omitempty"`
	Version          string   `json:"version,omitempty"`
	ForceSendFields  []string `json:"-"`
	NullFields       []string `json:"-"`
}

// BackendServiceCdnPolicy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceCdnPolicy struct {
	CacheKeyPolicy          *CacheKeyPolicy `json:"cacheKeyPolicy,omitempty"`
	SignedUrlCacheMaxAgeSec int64           `json:"signedUrlCacheMaxAgeSec,omitempty,string"`
	SignedUrlKeyNames       []string        `json:"signedUrlKeyNames,omitempty"`
	ForceSendFields         []string        `json:"-"`
	NullFields              []string        `json:"-"`
}

// BackendServiceCloudFunctionBackend is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceCloudFunctionBackend struct {
	FunctionName    string   `json:"functionName,omitempty"`
	TargetProject   string   `json:"targetProject,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// BackendServiceFailoverPolicy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceFailoverPolicy struct {
	DisableConnectionDrainOnFailover bool     `json:"disableConnectionDrainOnFailover,omitempty"`
	DropTrafficIfUnhealthy           bool     `json:"dropTrafficIfUnhealthy,omitempty"`
	FailoverRatio                    float64  `json:"failoverRatio,omitempty"`
	ForceSendFields                  []string `json:"-"`
	NullFields                       []string `json:"-"`
}

// BackendServiceIAP is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceIAP struct {
	Enabled                  bool                               `json:"enabled,omitempty"`
	Oauth2ClientId           string                             `json:"oauth2ClientId,omitempty"`
	Oauth2ClientInfo         *BackendServiceIAPOAuth2ClientInfo `json:"oauth2ClientInfo,omitempty"`
	Oauth2ClientSecret       string                             `json:"oauth2ClientSecret,omitempty"`
	Oauth2ClientSecretSha256 string                             `json:"oauth2ClientSecretSha256,omitempty"`
	ForceSendFields          []string                           `json:"-"`
	NullFields               []string                           `json:"-"`
}

// BackendServiceIAPOAuth2ClientInfo is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceIAPOAuth2ClientInfo struct {
	ApplicationName       string   `json:"applicationName,omitempty"`
	ClientName            string   `json:"clientName,omitempty"`
	DeveloperEmailAddress string   `json:"developerEmailAddress,omitempty"`
	ForceSendFields       []string `json:"-"`
	NullFields            []string `json:"-"`
}

// CacheKeyPolicy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type CacheKeyPolicy struct {
	IncludeHost          bool     `json:"includeHost,omitempty"`
	IncludeProtocol      bool     `json:"includeProtocol,omitempty"`
	IncludeQueryString   bool     `json:"includeQueryString,omitempty"`
	QueryStringBlacklist []string `json:"queryStringBlacklist,omitempty"`
	QueryStringWhitelist []string `json:"queryStringWhitelist,omitempty"`
	ForceSendFields      []string `json:"-"`
	NullFields           []string `json:"-"`
}

// ConnectionDraining is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type ConnectionDraining struct {
	DrainingTimeoutSec int64    `json:"drainingTimeoutSec,omitempty"`
	ForceSendFields    []string `json:"-"`
	NullFields         []string `json:"-"`
}

// ForwardingRule is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type ForwardingRule struct {
	// Version keeps track of the intended compute version for this ForwardingRule.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version                  meta.Version
	AllPorts                 bool              `json:"allPorts,omitempty"`
	AllowGlobalAccess        bool              `json:"allowGlobalAccess,omitempty"`
	BackendService           string            `json:"backendService,omitempty"`
	CreationTimestamp        string            `json:"creationTimestamp,omitempty"`
	Description              string            `json:"description,omitempty"`
	Fingerprint              string            `json:"fingerprint,omitempty"`
	IPAddress                string            `json:"IPAddress,omitempty"`
	IPProtocol               string            `json:"IPProtocol,omitempty"`
	Id                       uint64            `json:"id,omitempty,string"`
	IpVersion                string            `json:"ipVersion,omitempty"`
	Kind                     string            `json:"kind,omitempty"`
	LabelFingerprint         string            `json:"labelFingerprint,omitempty"`
	Labels                   map[string]string `json:"labels,omitempty"`
	LoadBalancingScheme      string            `json:"loadBalancingScheme,omitempty"`
	Name                     string            `json:"name,omitempty"`
	Network                  string            `json:"network,omitempty"`
	NetworkTier              string            `json:"networkTier,omitempty"`
	PortRange                string            `json:"portRange,omitempty"`
	Ports                    []string          `json:"ports,omitempty"`
	Region                   string            `json:"region,omitempty"`
	SelfLink                 string            `json:"selfLink,omitempty"`
	ServiceLabel             string            `json:"serviceLabel,omitempty"`
	ServiceName              string            `json:"serviceName,omitempty"`
	Subnetwork               string            `json:"subnetwork,omitempty"`
	Target                   string            `json:"target,omitempty"`
	googleapi.ServerResponse `json:"-"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// HostRule is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HostRule struct {
	Description     string   `json:"description,omitempty"`
	Hosts           []string `json:"hosts,omitempty"`
	PathMatcher     string   `json:"pathMatcher,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// HttpHealthCheck is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HttpHealthCheck struct {
	// Version keeps track of the intended compute version for this HttpHealthCheck.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version                  meta.Version
	CheckIntervalSec         int64  `json:"checkIntervalSec,omitempty"`
	CreationTimestamp        string `json:"creationTimestamp,omitempty"`
	Description              string `json:"description,omitempty"`
	HealthyThreshold         int64  `json:"healthyThreshold,omitempty"`
	Host                     string `json:"host,omitempty"`
	Id                       uint64 `json:"id,omitempty,string"`
	Kind                     string `json:"kind,omitempty"`
	Name                     string `json:"name,omitempty"`
	Port                     int64  `json:"port,omitempty"`
	RequestPath              string `json:"requestPath,omitempty"`
	SelfLink                 string `json:"selfLink,omitempty"`
	TimeoutSec               int64  `json:"timeoutSec,omitempty"`
	UnhealthyThreshold       int64  `json:"unhealthyThreshold,omitempty"`
	googleapi.ServerResponse `json:"-"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// HttpsHealthCheck is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HttpsHealthCheck struct {
	// Version keeps track of the intended compute version for this HttpsHealthCheck.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version                  meta.Version
	CheckIntervalSec         int64  `json:"checkIntervalSec,omitempty"`
	CreationTimestamp        string `json:"creationTimestamp,omitempty"`
	Description              string `json:"description,omitempty"`
	HealthyThreshold         int64  `json:"healthyThreshold,omitempty"`
	Host                     string `json:"host,omitempty"`
	Id                       uint64 `json:"id,omitempty,string"`
	Kind                     string `json:"kind,omitempty"`
	Name                     string `json:"name,omitempty"`
	Port                     int64  `json:"port,omitempty"`
	RequestPath              string `json:"requestPath,omitempty"`
	SelfLink                 string `json:"selfLink,omitempty"`
	TimeoutSec               int64  `json:"timeoutSec,omitempty"`
	UnhealthyThreshold       int64  `json:"unhealthyThreshold,omitempty"`
	googleapi.ServerResponse `json:"-"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// PathMatcher is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type PathMatcher struct {
	DefaultService  string      `json:"defaultService,omitempty"`
	Description     string      `json:"description,omitempty"`
	Name            string      `json:"name,omitempty"`
	PathRules       []*PathRule `json:"pathRules,omitempty"`
	ForceSendFields []string    `json:"-"`
	NullFields      []string    `json:"-"`
}

// PathRule is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type PathRule struct {
	Paths           []string `json:"paths,omitempty"`
	Service         string   `json:"service,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// TargetHttpProxy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type TargetHttpProxy struct {
	// Version keeps track of the intended compute version for this TargetHttpProxy.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version                  meta.Version
	CreationTimestamp        string `json:"creationTimestamp,omitempty"`
	Description              string `json:"description,omitempty"`
	Id                       uint64 `json:"id,omitempty,string"`
	Kind                     string `json:"kind,omitempty"`
	Name                     string `json:"name,omitempty"`
	Region                   string `json:"region,omitempty"`
	SelfLink                 string `json:"selfLink,omitempty"`
	UrlMap                   string `json:"urlMap,omitempty"`
	googleapi.ServerResponse `json:"-"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// TargetHttpsProxy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type TargetHttpsProxy struct {
	// Version keeps track of the intended compute version for this TargetHttpsProxy.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version                  meta.Version
	CreationTimestamp        string   `json:"creationTimestamp,omitempty"`
	Description              string   `json:"description,omitempty"`
	Id                       uint64   `json:"id,omitempty,string"`
	Kind                     string   `json:"kind,omitempty"`
	Name                     string   `json:"name,omitempty"`
	QuicOverride             string   `json:"quicOverride,omitempty"`
	Region                   string   `json:"region,omitempty"`
	SelfLink                 string   `json:"selfLink,omitempty"`
	SslCertificates          []string `json:"sslCertificates,omitempty"`
	SslPolicy                string   `json:"sslPolicy,omitempty"`
	UrlMap                   string   `json:"urlMap,omitempty"`
	googleapi.ServerResponse `json:"-"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// UrlMap is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type UrlMap struct {
	// Version keeps track of the intended compute version for this UrlMap.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version                  meta.Version
	CreationTimestamp        string         `json:"creationTimestamp,omitempty"`
	DefaultService           string         `json:"defaultService,omitempty"`
	Description              string         `json:"description,omitempty"`
	Fingerprint              string         `json:"fingerprint,omitempty"`
	HostRules                []*HostRule    `json:"hostRules,omitempty"`
	Id                       uint64         `json:"id,omitempty,string"`
	Kind                     string         `json:"kind,omitempty"`
	Name                     string         `json:"name,omitempty"`
	PathMatchers             []*PathMatcher `json:"pathMatchers,omitempty"`
	Region                   string         `json:"region,omitempty"`
	SelfLink                 string         `json:"selfLink,omitempty"`
	Tests                    []*UrlMapTest  `json:"tests,omitempty"`
	googleapi.ServerResponse `json:"-"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// UrlMapTest is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type UrlMapTest struct {
	Description     string   `json:"description,omitempty"`
	Host            string   `json:"host,omitempty"`
	Path            string   `json:"path,omitempty"`
	Service         string   `json:"service,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

func CreateBackendService(backendService *BackendService, cloud *gce.Cloud, key *meta.Key) error {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()

	switch backendService.Version {
	case meta.VersionAlpha:
		alpha, err := backendService.toAlpha()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating alpha BackendService %v", alpha.Name)
		return cloud.Compute().AlphaBackendServices().Insert(ctx, key, alpha)
	case meta.VersionBeta:
		beta, err := backendService.toBeta()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating beta BackendService %v", beta.Name)
		return cloud.Compute().BetaBackendServices().Insert(ctx, key, beta)
	default:
		ga, err := backendService.toGA()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating ga BackendService %v", ga.Name)
		return cloud.Compute().BackendServices().Insert(ctx, key, ga)
	}
}

func UpdateBackendService(backendService *BackendService, cloud *gce.Cloud, key *meta.Key) error {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()

	switch backendService.Version {
	case meta.VersionAlpha:
		alpha, err := backendService.toAlpha()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Updating alpha BackendService %v", alpha.Name)
		return cloud.Compute().AlphaBackendServices().Update(ctx, key, alpha)
	case meta.VersionBeta:
		beta, err := backendService.toBeta()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Updating beta BackendService %v", beta.Name)
		return cloud.Compute().BetaBackendServices().Update(ctx, key, beta)
	default:
		ga, err := backendService.toGA()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Updating ga BackendService %v", ga.Name)
		return cloud.Compute().BackendServices().Update(ctx, key, ga)
	}
}

func GetBackendService(name string, version meta.Version, cloud *gce.Cloud, key *meta.Key) (*BackendService, error) {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()

	var gceObj interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		gceObj, err = cloud.Compute().AlphaBackendServices().Get(ctx, key)
	case meta.VersionBeta:
		gceObj, err = cloud.Compute().BetaBackendServices().Get(ctx, key)
	default:
		gceObj, err = cloud.Compute().BackendServices().Get(ctx, key)
	}
	if err != nil {
		return nil, err
	}
	return toBackendService(gceObj)
}

// toBackendService converts a compute alpha, beta or GA
// BackendService into our composite type.
func toBackendService(obj interface{}) (*BackendService, error) {
	be := &BackendService{}
	bytes, err := json.Marshal(obj)
	if err != nil {
		return nil, fmt.Errorf("could not marshal object %+v to JSON: %v", obj, err)
	}
	err = json.Unmarshal(bytes, be)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling to BackendService: %v", err)
	}
	return be, nil
}

// toAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (backendService *BackendService) toAlpha() (*computealpha.BackendService, error) {
	bytes, err := json.Marshal(backendService)
	if err != nil {
		return nil, fmt.Errorf("error marshalling BackendService to JSON: %v", err)
	}
	alpha := &computealpha.BackendService{}
	err = json.Unmarshal(bytes, alpha)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling BackendService JSON to compute alpha type: %v", err)
	}
	// Set force send fields. This is a temporary hack.
	if alpha.CdnPolicy != nil && alpha.CdnPolicy.CacheKeyPolicy != nil {
		alpha.CdnPolicy.CacheKeyPolicy.ForceSendFields = []string{"IncludeHost", "IncludeProtocol", "IncludeQueryString", "QueryStringBlacklist", "QueryStringWhitelist"}
	}
	if alpha.Iap != nil {
		alpha.Iap.ForceSendFields = []string{"Enabled", "Oauth2ClientId", "Oauth2ClientSecret"}
	}

	return alpha, nil
}

// toBeta converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (backendService *BackendService) toBeta() (*computebeta.BackendService, error) {
	bytes, err := json.Marshal(backendService)
	if err != nil {
		return nil, fmt.Errorf("error marshalling BackendService to JSON: %v", err)
	}
	beta := &computebeta.BackendService{}
	err = json.Unmarshal(bytes, beta)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling BackendService JSON to compute beta type: %v", err)
	}
	// Set force send fields. This is a temporary hack.
	if beta.CdnPolicy != nil && beta.CdnPolicy.CacheKeyPolicy != nil {
		beta.CdnPolicy.CacheKeyPolicy.ForceSendFields = []string{"IncludeHost", "IncludeProtocol", "IncludeQueryString", "QueryStringBlacklist", "QueryStringWhitelist"}
	}
	if beta.Iap != nil {
		beta.Iap.ForceSendFields = []string{"Enabled", "Oauth2ClientId", "Oauth2ClientSecret"}
	}

	return beta, nil
}

// toGA converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (backendService *BackendService) toGA() (*compute.BackendService, error) {
	bytes, err := json.Marshal(backendService)
	if err != nil {
		return nil, fmt.Errorf("error marshalling BackendService to JSON: %v", err)
	}
	ga := &compute.BackendService{}
	err = json.Unmarshal(bytes, ga)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling BackendService JSON to compute ga type: %v", err)
	}
	// Set force send fields. This is a temporary hack.
	if ga.CdnPolicy != nil && ga.CdnPolicy.CacheKeyPolicy != nil {
		ga.CdnPolicy.CacheKeyPolicy.ForceSendFields = []string{"IncludeHost", "IncludeProtocol", "IncludeQueryString", "QueryStringBlacklist", "QueryStringWhitelist"}
	}
	if ga.Iap != nil {
		ga.Iap.ForceSendFields = []string{"Enabled", "Oauth2ClientId", "Oauth2ClientSecret"}
	}

	return ga, nil
}

func CreateForwardingRule(forwardingRule *ForwardingRule, cloud *gce.Cloud, key *meta.Key) error {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()

	switch forwardingRule.Version {
	case meta.VersionAlpha:
		alpha, err := forwardingRule.toAlpha()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating alpha ForwardingRule %v", alpha.Name)
		return cloud.Compute().AlphaForwardingRules().Insert(ctx, key, alpha)
	case meta.VersionBeta:
		beta, err := forwardingRule.toBeta()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating beta ForwardingRule %v", beta.Name)
		return cloud.Compute().BetaForwardingRules().Insert(ctx, key, beta)
	default:
		ga, err := forwardingRule.toGA()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating ga ForwardingRule %v", ga.Name)
		return cloud.Compute().ForwardingRules().Insert(ctx, key, ga)
	}
}

func GetForwardingRule(name string, version meta.Version, cloud *gce.Cloud, key *meta.Key) (*ForwardingRule, error) {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()

	var gceObj interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		gceObj, err = cloud.Compute().AlphaForwardingRules().Get(ctx, key)
	case meta.VersionBeta:
		gceObj, err = cloud.Compute().BetaForwardingRules().Get(ctx, key)
	default:
		gceObj, err = cloud.Compute().ForwardingRules().Get(ctx, key)
	}
	if err != nil {
		return nil, err
	}
	return toForwardingRule(gceObj)
}

// toForwardingRule converts a compute alpha, beta or GA
// ForwardingRule into our composite type.
func toForwardingRule(obj interface{}) (*ForwardingRule, error) {
	be := &ForwardingRule{}
	bytes, err := json.Marshal(obj)
	if err != nil {
		return nil, fmt.Errorf("could not marshal object %+v to JSON: %v", obj, err)
	}
	err = json.Unmarshal(bytes, be)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling to ForwardingRule: %v", err)
	}
	return be, nil
}

// toAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (forwardingRule *ForwardingRule) toAlpha() (*computealpha.ForwardingRule, error) {
	bytes, err := json.Marshal(forwardingRule)
	if err != nil {
		return nil, fmt.Errorf("error marshalling ForwardingRule to JSON: %v", err)
	}
	alpha := &computealpha.ForwardingRule{}
	err = json.Unmarshal(bytes, alpha)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling ForwardingRule JSON to compute alpha type: %v", err)
	}

	return alpha, nil
}

// toBeta converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (forwardingRule *ForwardingRule) toBeta() (*computebeta.ForwardingRule, error) {
	bytes, err := json.Marshal(forwardingRule)
	if err != nil {
		return nil, fmt.Errorf("error marshalling ForwardingRule to JSON: %v", err)
	}
	beta := &computebeta.ForwardingRule{}
	err = json.Unmarshal(bytes, beta)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling ForwardingRule JSON to compute beta type: %v", err)
	}

	return beta, nil
}

// toGA converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (forwardingRule *ForwardingRule) toGA() (*compute.ForwardingRule, error) {
	bytes, err := json.Marshal(forwardingRule)
	if err != nil {
		return nil, fmt.Errorf("error marshalling ForwardingRule to JSON: %v", err)
	}
	ga := &compute.ForwardingRule{}
	err = json.Unmarshal(bytes, ga)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling ForwardingRule JSON to compute ga type: %v", err)
	}

	return ga, nil
}

func CreateHttpHealthCheck(httpHealthCheck *HttpHealthCheck, cloud *gce.Cloud, key *meta.Key) error {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()

	switch httpHealthCheck.Version {
	case meta.VersionAlpha:
		alpha, err := httpHealthCheck.toAlpha()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating alpha HttpHealthCheck %v", alpha.Name)
		return cloud.Compute().AlphaHttpHealthChecks().Insert(ctx, key, alpha)
	case meta.VersionBeta:
		beta, err := httpHealthCheck.toBeta()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating beta HttpHealthCheck %v", beta.Name)
		return cloud.Compute().BetaHttpHealthChecks().Insert(ctx, key, beta)
	default:
		ga, err := httpHealthCheck.toGA()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating ga HttpHealthCheck %v", ga.Name)
		return cloud.Compute().HttpHealthChecks().Insert(ctx, key, ga)
	}
}

func UpdateHttpHealthCheck(httpHealthCheck *HttpHealthCheck, cloud *gce.Cloud, key *meta.Key) error {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()

	switch httpHealthCheck.Version {
	case meta.VersionAlpha:
		alpha, err := httpHealthCheck.toAlpha()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Updating alpha HttpHealthCheck %v", alpha.Name)
		return cloud.Compute().AlphaHttpHealthChecks().Update(ctx, key, alpha)
	case meta.VersionBeta:
		beta, err := httpHealthCheck.toBeta()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Updating beta HttpHealthCheck %v", beta.Name)
		return cloud.Compute().BetaHttpHealthChecks().Update(ctx, key, beta)
	default:
		ga, err := httpHealthCheck.toGA()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Updating ga HttpHealthCheck %v", ga.Name)
		return cloud.Compute().HttpHealthChecks().Update(ctx, key, ga)
	}
}

func GetHttpHealthCheck(name string, version meta.Version, cloud *gce.Cloud, key *meta.Key) (*HttpHealthCheck, error) {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()

	var gceObj interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		gceObj, err = cloud.Compute().AlphaHttpHealthChecks().Get(ctx, key)
	case meta.VersionBeta:
		gceObj, err = cloud.Compute().BetaHttpHealthChecks().Get(ctx, key)
	default:
		gceObj, err = cloud.Compute().HttpHealthChecks().Get(ctx, key)
	}
	if err != nil {
		return nil, err
	}
	return toHttpHealthCheck(gceObj)
}

// toHttpHealthCheck converts a compute alpha, beta or GA
// HttpHealthCheck into our composite type.
func toHttpHealthCheck(obj interface{}) (*HttpHealthCheck, error) {
	be := &HttpHealthCheck{}
	bytes, err := json.Marshal(obj)
	if err != nil {
		return nil, fmt.Errorf("could not marshal object %+v to JSON: %v", obj, err)
	}
	err = json.Unmarshal(bytes, be)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling to HttpHealthCheck: %v", err)
	}
	return be, nil
}

// toAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (httpHealthCheck *HttpHealthCheck) toAlpha() (*computealpha.HttpHealthCheck, error) {
	bytes, err := json.Marshal(httpHealthCheck)
	if err != nil {
		return nil, fmt.Errorf("error marshalling HttpHealthCheck to JSON: %v", err)
	}
	alpha := &computealpha.HttpHealthCheck{}
	err = json.Unmarshal(bytes, alpha)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling HttpHealthCheck JSON to compute alpha type: %v", err)
	}

	return alpha, nil
}

// toBeta converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (httpHealthCheck *HttpHealthCheck) toBeta() (*computebeta.HttpHealthCheck, error) {
	bytes, err := json.Marshal(httpHealthCheck)
	if err != nil {
		return nil, fmt.Errorf("error marshalling HttpHealthCheck to JSON: %v", err)
	}
	beta := &computebeta.HttpHealthCheck{}
	err = json.Unmarshal(bytes, beta)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling HttpHealthCheck JSON to compute beta type: %v", err)
	}

	return beta, nil
}

// toGA converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (httpHealthCheck *HttpHealthCheck) toGA() (*compute.HttpHealthCheck, error) {
	bytes, err := json.Marshal(httpHealthCheck)
	if err != nil {
		return nil, fmt.Errorf("error marshalling HttpHealthCheck to JSON: %v", err)
	}
	ga := &compute.HttpHealthCheck{}
	err = json.Unmarshal(bytes, ga)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling HttpHealthCheck JSON to compute ga type: %v", err)
	}

	return ga, nil
}

func CreateHttpsHealthCheck(httpsHealthCheck *HttpsHealthCheck, cloud *gce.Cloud, key *meta.Key) error {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()

	switch httpsHealthCheck.Version {
	case meta.VersionAlpha:
		alpha, err := httpsHealthCheck.toAlpha()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating alpha HttpsHealthCheck %v", alpha.Name)
		return cloud.Compute().AlphaHttpsHealthChecks().Insert(ctx, key, alpha)
	case meta.VersionBeta:
		beta, err := httpsHealthCheck.toBeta()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating beta HttpsHealthCheck %v", beta.Name)
		return cloud.Compute().BetaHttpsHealthChecks().Insert(ctx, key, beta)
	default:
		ga, err := httpsHealthCheck.toGA()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating ga HttpsHealthCheck %v", ga.Name)
		return cloud.Compute().HttpsHealthChecks().Insert(ctx, key, ga)
	}
}

func UpdateHttpsHealthCheck(httpsHealthCheck *HttpsHealthCheck, cloud *gce.Cloud, key *meta.Key) error {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()

	switch httpsHealthCheck.Version {
	case meta.VersionAlpha:
		alpha, err := httpsHealthCheck.toAlpha()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Updating alpha HttpsHealthCheck %v", alpha.Name)
		return cloud.Compute().AlphaHttpsHealthChecks().Update(ctx, key, alpha)
	case meta.VersionBeta:
		beta, err := httpsHealthCheck.toBeta()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Updating beta HttpsHealthCheck %v", beta.Name)
		return cloud.Compute().BetaHttpsHealthChecks().Update(ctx, key, beta)
	default:
		ga, err := httpsHealthCheck.toGA()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Updating ga HttpsHealthCheck %v", ga.Name)
		return cloud.Compute().HttpsHealthChecks().Update(ctx, key, ga)
	}
}

func GetHttpsHealthCheck(name string, version meta.Version, cloud *gce.Cloud, key *meta.Key) (*HttpsHealthCheck, error) {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()

	var gceObj interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		gceObj, err = cloud.Compute().AlphaHttpsHealthChecks().Get(ctx, key)
	case meta.VersionBeta:
		gceObj, err = cloud.Compute().BetaHttpsHealthChecks().Get(ctx, key)
	default:
		gceObj, err = cloud.Compute().HttpsHealthChecks().Get(ctx, key)
	}
	if err != nil {
		return nil, err
	}
	return toHttpsHealthCheck(gceObj)
}

// toHttpsHealthCheck converts a compute alpha, beta or GA
// HttpsHealthCheck into our composite type.
func toHttpsHealthCheck(obj interface{}) (*HttpsHealthCheck, error) {
	be := &HttpsHealthCheck{}
	bytes, err := json.Marshal(obj)
	if err != nil {
		return nil, fmt.Errorf("could not marshal object %+v to JSON: %v", obj, err)
	}
	err = json.Unmarshal(bytes, be)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling to HttpsHealthCheck: %v", err)
	}
	return be, nil
}

// toAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (httpsHealthCheck *HttpsHealthCheck) toAlpha() (*computealpha.HttpsHealthCheck, error) {
	bytes, err := json.Marshal(httpsHealthCheck)
	if err != nil {
		return nil, fmt.Errorf("error marshalling HttpsHealthCheck to JSON: %v", err)
	}
	alpha := &computealpha.HttpsHealthCheck{}
	err = json.Unmarshal(bytes, alpha)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling HttpsHealthCheck JSON to compute alpha type: %v", err)
	}

	return alpha, nil
}

// toBeta converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (httpsHealthCheck *HttpsHealthCheck) toBeta() (*computebeta.HttpsHealthCheck, error) {
	bytes, err := json.Marshal(httpsHealthCheck)
	if err != nil {
		return nil, fmt.Errorf("error marshalling HttpsHealthCheck to JSON: %v", err)
	}
	beta := &computebeta.HttpsHealthCheck{}
	err = json.Unmarshal(bytes, beta)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling HttpsHealthCheck JSON to compute beta type: %v", err)
	}

	return beta, nil
}

// toGA converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (httpsHealthCheck *HttpsHealthCheck) toGA() (*compute.HttpsHealthCheck, error) {
	bytes, err := json.Marshal(httpsHealthCheck)
	if err != nil {
		return nil, fmt.Errorf("error marshalling HttpsHealthCheck to JSON: %v", err)
	}
	ga := &compute.HttpsHealthCheck{}
	err = json.Unmarshal(bytes, ga)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling HttpsHealthCheck JSON to compute ga type: %v", err)
	}

	return ga, nil
}

func CreateTargetHttpProxy(targetHttpProxy *TargetHttpProxy, cloud *gce.Cloud, key *meta.Key) error {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()

	switch targetHttpProxy.Version {
	case meta.VersionAlpha:
		alpha, err := targetHttpProxy.toAlpha()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating alpha TargetHttpProxy %v", alpha.Name)
		return cloud.Compute().AlphaTargetHttpProxies().Insert(ctx, key, alpha)
	case meta.VersionBeta:
		beta, err := targetHttpProxy.toBeta()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating beta TargetHttpProxy %v", beta.Name)
		return cloud.Compute().BetaTargetHttpProxies().Insert(ctx, key, beta)
	default:
		ga, err := targetHttpProxy.toGA()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating ga TargetHttpProxy %v", ga.Name)
		return cloud.Compute().TargetHttpProxies().Insert(ctx, key, ga)
	}
}

func GetTargetHttpProxy(name string, version meta.Version, cloud *gce.Cloud, key *meta.Key) (*TargetHttpProxy, error) {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()

	var gceObj interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		gceObj, err = cloud.Compute().AlphaTargetHttpProxies().Get(ctx, key)
	case meta.VersionBeta:
		gceObj, err = cloud.Compute().BetaTargetHttpProxies().Get(ctx, key)
	default:
		gceObj, err = cloud.Compute().TargetHttpProxies().Get(ctx, key)
	}
	if err != nil {
		return nil, err
	}
	return toTargetHttpProxy(gceObj)
}

// toTargetHttpProxy converts a compute alpha, beta or GA
// TargetHttpProxy into our composite type.
func toTargetHttpProxy(obj interface{}) (*TargetHttpProxy, error) {
	be := &TargetHttpProxy{}
	bytes, err := json.Marshal(obj)
	if err != nil {
		return nil, fmt.Errorf("could not marshal object %+v to JSON: %v", obj, err)
	}
	err = json.Unmarshal(bytes, be)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling to TargetHttpProxy: %v", err)
	}
	return be, nil
}

// toAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (targetHttpProxy *TargetHttpProxy) toAlpha() (*computealpha.TargetHttpProxy, error) {
	bytes, err := json.Marshal(targetHttpProxy)
	if err != nil {
		return nil, fmt.Errorf("error marshalling TargetHttpProxy to JSON: %v", err)
	}
	alpha := &computealpha.TargetHttpProxy{}
	err = json.Unmarshal(bytes, alpha)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling TargetHttpProxy JSON to compute alpha type: %v", err)
	}

	return alpha, nil
}

// toBeta converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (targetHttpProxy *TargetHttpProxy) toBeta() (*computebeta.TargetHttpProxy, error) {
	bytes, err := json.Marshal(targetHttpProxy)
	if err != nil {
		return nil, fmt.Errorf("error marshalling TargetHttpProxy to JSON: %v", err)
	}
	beta := &computebeta.TargetHttpProxy{}
	err = json.Unmarshal(bytes, beta)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling TargetHttpProxy JSON to compute beta type: %v", err)
	}

	return beta, nil
}

// toGA converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (targetHttpProxy *TargetHttpProxy) toGA() (*compute.TargetHttpProxy, error) {
	bytes, err := json.Marshal(targetHttpProxy)
	if err != nil {
		return nil, fmt.Errorf("error marshalling TargetHttpProxy to JSON: %v", err)
	}
	ga := &compute.TargetHttpProxy{}
	err = json.Unmarshal(bytes, ga)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling TargetHttpProxy JSON to compute ga type: %v", err)
	}

	return ga, nil
}

func CreateTargetHttpsProxy(targetHttpsProxy *TargetHttpsProxy, cloud *gce.Cloud, key *meta.Key) error {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()

	switch targetHttpsProxy.Version {
	case meta.VersionAlpha:
		alpha, err := targetHttpsProxy.toAlpha()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating alpha TargetHttpsProxy %v", alpha.Name)
		return cloud.Compute().AlphaTargetHttpsProxies().Insert(ctx, key, alpha)
	case meta.VersionBeta:
		beta, err := targetHttpsProxy.toBeta()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating beta TargetHttpsProxy %v", beta.Name)
		return cloud.Compute().BetaTargetHttpsProxies().Insert(ctx, key, beta)
	default:
		ga, err := targetHttpsProxy.toGA()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating ga TargetHttpsProxy %v", ga.Name)
		return cloud.Compute().TargetHttpsProxies().Insert(ctx, key, ga)
	}
}

func GetTargetHttpsProxy(name string, version meta.Version, cloud *gce.Cloud, key *meta.Key) (*TargetHttpsProxy, error) {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()

	var gceObj interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		gceObj, err = cloud.Compute().AlphaTargetHttpsProxies().Get(ctx, key)
	case meta.VersionBeta:
		gceObj, err = cloud.Compute().BetaTargetHttpsProxies().Get(ctx, key)
	default:
		gceObj, err = cloud.Compute().TargetHttpsProxies().Get(ctx, key)
	}
	if err != nil {
		return nil, err
	}
	return toTargetHttpsProxy(gceObj)
}

// toTargetHttpsProxy converts a compute alpha, beta or GA
// TargetHttpsProxy into our composite type.
func toTargetHttpsProxy(obj interface{}) (*TargetHttpsProxy, error) {
	be := &TargetHttpsProxy{}
	bytes, err := json.Marshal(obj)
	if err != nil {
		return nil, fmt.Errorf("could not marshal object %+v to JSON: %v", obj, err)
	}
	err = json.Unmarshal(bytes, be)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling to TargetHttpsProxy: %v", err)
	}
	return be, nil
}

// toAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (targetHttpsProxy *TargetHttpsProxy) toAlpha() (*computealpha.TargetHttpsProxy, error) {
	bytes, err := json.Marshal(targetHttpsProxy)
	if err != nil {
		return nil, fmt.Errorf("error marshalling TargetHttpsProxy to JSON: %v", err)
	}
	alpha := &computealpha.TargetHttpsProxy{}
	err = json.Unmarshal(bytes, alpha)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling TargetHttpsProxy JSON to compute alpha type: %v", err)
	}

	return alpha, nil
}

// toBeta converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (targetHttpsProxy *TargetHttpsProxy) toBeta() (*computebeta.TargetHttpsProxy, error) {
	bytes, err := json.Marshal(targetHttpsProxy)
	if err != nil {
		return nil, fmt.Errorf("error marshalling TargetHttpsProxy to JSON: %v", err)
	}
	beta := &computebeta.TargetHttpsProxy{}
	err = json.Unmarshal(bytes, beta)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling TargetHttpsProxy JSON to compute beta type: %v", err)
	}

	return beta, nil
}

// toGA converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (targetHttpsProxy *TargetHttpsProxy) toGA() (*compute.TargetHttpsProxy, error) {
	bytes, err := json.Marshal(targetHttpsProxy)
	if err != nil {
		return nil, fmt.Errorf("error marshalling TargetHttpsProxy to JSON: %v", err)
	}
	ga := &compute.TargetHttpsProxy{}
	err = json.Unmarshal(bytes, ga)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling TargetHttpsProxy JSON to compute ga type: %v", err)
	}

	return ga, nil
}

func CreateUrlMap(urlMap *UrlMap, cloud *gce.Cloud, key *meta.Key) error {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()

	switch urlMap.Version {
	case meta.VersionAlpha:
		alpha, err := urlMap.toAlpha()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating alpha UrlMap %v", alpha.Name)
		return cloud.Compute().AlphaUrlMaps().Insert(ctx, key, alpha)
	case meta.VersionBeta:
		beta, err := urlMap.toBeta()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating beta UrlMap %v", beta.Name)
		return cloud.Compute().BetaUrlMaps().Insert(ctx, key, beta)
	default:
		ga, err := urlMap.toGA()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating ga UrlMap %v", ga.Name)
		return cloud.Compute().UrlMaps().Insert(ctx, key, ga)
	}
}

func UpdateUrlMap(urlMap *UrlMap, cloud *gce.Cloud, key *meta.Key) error {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()

	switch urlMap.Version {
	case meta.VersionAlpha:
		alpha, err := urlMap.toAlpha()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Updating alpha UrlMap %v", alpha.Name)
		return cloud.Compute().AlphaUrlMaps().Update(ctx, key, alpha)
	case meta.VersionBeta:
		beta, err := urlMap.toBeta()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Updating beta UrlMap %v", beta.Name)
		return cloud.Compute().BetaUrlMaps().Update(ctx, key, beta)
	default:
		ga, err := urlMap.toGA()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Updating ga UrlMap %v", ga.Name)
		return cloud.Compute().UrlMaps().Update(ctx, key, ga)
	}
}

func GetUrlMap(name string, version meta.Version, cloud *gce.Cloud, key *meta.Key) (*UrlMap, error) {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()

	var gceObj interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		gceObj, err = cloud.Compute().AlphaUrlMaps().Get(ctx, key)
	case meta.VersionBeta:
		gceObj, err = cloud.Compute().BetaUrlMaps().Get(ctx, key)
	default:
		gceObj, err = cloud.Compute().UrlMaps().Get(ctx, key)
	}
	if err != nil {
		return nil, err
	}
	return toUrlMap(gceObj)
}

// toUrlMap converts a compute alpha, beta or GA
// UrlMap into our composite type.
func toUrlMap(obj interface{}) (*UrlMap, error) {
	be := &UrlMap{}
	bytes, err := json.Marshal(obj)
	if err != nil {
		return nil, fmt.Errorf("could not marshal object %+v to JSON: %v", obj, err)
	}
	err = json.Unmarshal(bytes, be)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling to UrlMap: %v", err)
	}
	return be, nil
}

// toAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (urlMap *UrlMap) toAlpha() (*computealpha.UrlMap, error) {
	bytes, err := json.Marshal(urlMap)
	if err != nil {
		return nil, fmt.Errorf("error marshalling UrlMap to JSON: %v", err)
	}
	alpha := &computealpha.UrlMap{}
	err = json.Unmarshal(bytes, alpha)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling UrlMap JSON to compute alpha type: %v", err)
	}

	return alpha, nil
}

// toBeta converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (urlMap *UrlMap) toBeta() (*computebeta.UrlMap, error) {
	bytes, err := json.Marshal(urlMap)
	if err != nil {
		return nil, fmt.Errorf("error marshalling UrlMap to JSON: %v", err)
	}
	beta := &computebeta.UrlMap{}
	err = json.Unmarshal(bytes, beta)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling UrlMap JSON to compute beta type: %v", err)
	}

	return beta, nil
}

// toGA converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (urlMap *UrlMap) toGA() (*compute.UrlMap, error) {
	bytes, err := json.Marshal(urlMap)
	if err != nil {
		return nil, fmt.Errorf("error marshalling UrlMap to JSON: %v", err)
	}
	ga := &compute.UrlMap{}
	err = json.Unmarshal(bytes, ga)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling UrlMap JSON to compute ga type: %v", err)
	}

	return ga, nil
}
